/**
 * Contains utility functions that generate Nix expressions from NPM package specifications
 * @module node2nix
 */
var fs = require('fs');
var path = require('path');
var slasp = require('slasp');
var nijs = require('nijs');

var CollectionExpression = require('./expressions/CollectionExpression.js').CollectionExpression;
var PackageExpression = require('./expressions/PackageExpression.js').PackageExpression;
var CompositionExpression = require('./expressions/CompositionExpression.js').CompositionExpression;
var DeploymentConfig = require('./DeploymentConfig.js').DeploymentConfig;

function copyNodeEnvExpr(nodeEnvNix, callback) {
    /* Compose a read stream that reads the build expression */
    var rs = fs.createReadStream(path.join(path.dirname(module.filename), "..", "nix", "node-env.nix"));
    rs.on("error", function(err) {
        callback(err);
    });

    /* Compose a write stream that writes the build expression */
    var ws = fs.createWriteStream(nodeEnvNix);
    ws.on("error", function(err) {
        callback(err);
    });
    ws.on("close", function() {
        callback(null);
    });

    /* Pipe the data to actually copy stuff */
    rs.pipe(ws);
}

/**
 * Writes a copy of node-env.nix to a specified path.
 *
 * @function
 * @param {String} nodeEnvNix Path to which the NPM package build expression is written
 * @param {function(String)} callback Callback function that gets invoked if the operation is done.
 *     If an error has occured, the error parameter is set to the error message.
 */
exports.copyNodeEnvExpr = copyNodeEnvExpr;

function npmToNix(inputJSON, outputNix, compositionNix, nodeEnvNix, supplementJSON, supplementNix, production, includePeerDependencies, flatten, nodePackage, noCopyNodeEnv, callback) {
    var obj = JSON.parse(fs.readFileSync(inputJSON));
    var version = JSON.parse(fs.readFileSync(path.join(__dirname, "..", "package.json"))).version;
    var disclaimer = "# This file has been generated by node2nix " + version + ". Do not edit!\n\n";
    var outputDir = path.dirname(outputNix);
    var baseDir = path.dirname(inputJSON);
    var deploymentConfig = new DeploymentConfig(production, includePeerDependencies, flatten, nodePackage, outputDir);
    var expr;

    slasp.sequence([
        /* Generate a Nix expression */
        function(callback) {
            if(typeof obj == "object" && obj !== null) {
                if(Array.isArray(obj)) {
                    expr = new CollectionExpression(deploymentConfig, baseDir, obj);
                } else {
                    expr = new PackageExpression(deploymentConfig, baseDir, obj.name, baseDir);
                }

                expr.resolveDependencies(callback);
            } else {
                callback("The provided JSON file must consist of an object or an array");
            }
        },

        /* Write the output Nix expression to the specified output file */
        function(callback) {
            fs.writeFile(outputNix, disclaimer + nijs.jsToNix(expr, true), callback);
        },

        function(callback) {
            /* Generate the supplement Nix expression, if specified */
            if(supplementJSON) {
                var obj = JSON.parse(fs.readFileSync(supplementJSON));

                if(Array.isArray(obj)) {
                    expr = new CollectionExpression(deploymentConfig, baseDir, obj);
                    expr.resolveDependencies(callback);
                } else {
                    callback("The supplement JSON file should be an array");
                }
            } else {
                expr = undefined;
                callback();
            }
        },

        function(callback) {
            if(expr === undefined) {
                callback();
            } else {
                /* Write the supplement Nix expression to the specified output file */
                fs.writeFile(supplementNix, disclaimer + nijs.jsToNix(expr, true), callback);
            }
        },

        function(callback) {
            if(noCopyNodeEnv) {
                callback();
            } else {
                /* Copy the node-env.nix expression */
                copyNodeEnvExpr(nodeEnvNix, callback);
            }
        },

        /* Generate and write a Nix composition expression to the specified output file */
        function(callback) {
            expr = new CompositionExpression(nodePackage, nodeEnvNix, outputNix, supplementNix, (supplementJSON !== undefined));
            fs.writeFile(compositionNix, disclaimer + nijs.jsToNix(expr, true), callback);
        }
    ], callback);
}

/**
 * Generates a Nix expression from a JSON file representing a Node.js package
 * configuration or an array of NPM dependencies.
 *
 * @function
 * @param {String} inputJSON Path to a package.json or arbitrary JSON file
 * @param {String} outputNix Path to which the generated registry expression is written
 * @param {String} compositionNix Path to which the generated composition expression is written
 * @param {String} nodeEnvNix Path to which the NPM package build expression is written
 * @param {String} supplementJSON Path to a supplement JSON file
 * @param {String} supplementNix Path to which the generated supplement expression is written
 * @param {Boolean} production Indicates whether to deploy the package in production mode
 * @param {Boolean} includePeerDependencies Indicates whether to include peer dependencies with the package
 * @param {Boolean} flatten Indicates whether to create a flat dependency structure in which dependencies are as high as possible in the graph
 * @param {String} nodePackage Name of the Node.js package to use from Nixpkgs
 * @param {Boolean} noCopyNodeEnv Indicates that no copy of the NPM package build expression should be made
 * @param {function(String, String)} callback Callback function that gets invoked when the work is done.
 *     If an error occurs, the error parameter is set to contain the error
 *     If the operation succeeds, it returns a string containing the registry expression containing the packages and all its dependencies
 */
exports.npmToNix = npmToNix;
